[{"title":"Kotlin React App","date":"2019-12-20T07:51:00.000Z","path":"2019/12/20/Kotlin-React-App/","text":"Great guide for Kotlin + React: https://play.kotlinlang.org/hands-on/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/01_Introduction Instead of using JSX, Kotlin React is using its own domain-specific language (DSL) to describe it: https://medium.com/@ralf.stuckert/getting-started-with-kotlin-react-c5f3b079a8bf Frontend with Kotlin/JSJetBrains create-react-kotlin-app repo: https://github.com/JetBrains/create-react-kotlin-app JetBrains kotlin-react-router-dom repo: https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-router-dom I have create a repo, and coding here: https://github.com/ericwdq/kotlin-react-app Add the kotlin-react-router-dom to the app, in order to integrate react-kotlin app into micro frontend container We need to add @jetbrains/kotlin-react-router-dom” modules to package.json by using commands List “browserRouter” or “hashRouter” to register the react routers Creating navigation component like sidebar for routing, and expose the paths to container Can reuse react components from npm : https://play.kotlinlang.org/hands-on/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/07_Using_Packages_From_NPM → but need to add types manually → can this be used to reuse fiori for react components? components we wrote in JS? List of reusable, pre-typed projects: https://github.com/JetBrains/kotlin-wrappers How to add dependency into project, take fundamental-react for example We have to wrap each fundamental control/component, because fundamental index don’t have a default export. And each file will export a single component, which will be a huge workload as fundamental react has many components, and the content may changed. We can package fundamental-react in a specified naming space, and export them as a common library to all projects Use @file:JsModule(“fundamental-react/Button”) to define a component, and better to add an interface ButtonProps to make it typed Code snippet may like those Next step is how to package them into ui-framework and ui-utils template. Microfrontend compatible? code split?","tags":[{"name":"React","slug":"React","permalink":"https://blog.v2next.com/tags/React/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.v2next.com/tags/Kotlin/"}]},{"title":"GraphQL Apollo Server implementation","date":"2019-10-28T08:16:52.000Z","path":"2019/10/28/GraphQL-Apollo-Server-implementation/","text":"目标是采用一个GraphQL库，能够使用较小的payload调用后端查询的API，减少HTTP请求和响应的时间，优化API数据访问速度。 当然GraphQL还有很多的优势，能根据客户端的期望来返回API结构按需获取，API First，强类型 Schema，可以组合和连接多个GraphQL API，合并为一个API等等。 我们选择了GraphQL Apollo Server的ExpressJS库, 运行在NodeJS中。 下面客户端和服务器的Apollo GraphQL工作流程： https://www.apollographql.com/docs/apollo-server/ 配置 Apollo Server 和 ExpressJS 在 NodeJS:安装依赖使用下面的命令：1yarn add apollo-server-express graphql graphql-tools Or 1npm install apollo-server-express graphql graphql-tools 创建 GraphQL Schema12345678910const ApolloServer= new ApolloServer(&#123; typeDefs: Types, resolvers: Resolvers, playground: &#123; endpoint: `/graphql`, settings: &#123; 'editor.theme': 'light', &#125;, &#125;,&#125;); 创建 GraphQL Apollo 服务器使用基本选项1234ApolloServer.applyMiddleware(&#123; app: app, // this parameter is express application path: '/graphql',&#125;); 创建 GraphQL Query以调用BusinessPartner api为例1234type Query &#123; BusinessPartner(Id: Int!): BusinessPartner BusinessPartners: [BusinessPartner]&#125; 创建 GraphQL Type12345678type BusinessPartner &#123; Id: Int BusinessPartner: Int BusinessPartnerName: String SearchTerm1: String CreatedByUser: String BusinessPartnerAddress: [BusinessPartnerAddress]&#125; 创建 GraphQL Resolvers1234567BusinessPartner: async ( parent: void, args: any, info: GraphQLResolveInfo, ) =&gt; &#123; return await api.getBusinessPartner(args.Id);&#125;, 完成创建后,运行 yarn start, 你可以访问 http://localhost:3000/graphql 和测试你的 GraphQL query在Apollo Playgound. GraphQL有两种类型 Query 和 Mutation。 下面是我学习查找一些有用的资源https://graphql.org/https://graphql.org/code/https://graphql.org/code/#javascripthttps://github.com/graphql/graphql-js/https://github.com/graphql/graphiql/ graphiqlhttps://www.apollographql.com/docs/apollo-server/ GraphQL Best Practiceshttps://graphql.org/learn/best-practices/ Apollo graphql server:https://www.apollographql.com/docs/apollo-server/https://www.howtographql.com/graphql-js/8-filtering-pagination-and-sorting/ Server:https://graphql.org/graphql-js/running-an-express-graphql-server/https://graphql.org/code/#javascript https://github.com/graphql/graphql-spechttps://graphql.github.io/graphql-spec/June2018/https://blog.apollographql.com/three-ways-to-represent-your-graphql-schema-a41f4175100d Client: https://graphql.org/graphql-js/graphql-clients/https://github.com/prisma/graphql-request Facebook data loader: https://github.com/graphql/dataloader GraphQL API v4 Githubhttps://developer.github.com/v4/ Dynamic schema and resolver generationhttps://www.contentful.com/blog/2018/12/21/dynamic-schema-generation-changing-data-models/https://blog.hasura.io/the-ultimate-guide-to-schema-stitching-in-graphql-f30178ac0072/https://github.com/apollographql/apollo-server/issues/2560 https://medium.com/open-graphql/graphql-dynamic-persisted-queries-eb259700f1d3 Modularizing your GraphQL schema codehttps://blog.apollographql.com/modularizing-your-graphql-schema-code-d7f71d5ed5f2每个 service 的数据结构契约，都放入了一个大而全的 GraphQL Schema 里；如果不做任何模块化和解耦，开发体验将会非常糟糕。每个团队成员，都去修改同一份 Schema 文件。这明显是不合理的。GraphQL-BFF 的开发模式，应该跟 service 的领域模型，有一一对应的关系。然后通过某种形式，多个 services 自然整合到一起。 GraphQL-BFF：微服务背景下的前后端数据交互方案https://zhuanlan.zhihu.com/p/75241522开发语言选用了 TypeScript，跑在 Node.js v10.x 版本上，服务端框架是 Koa v2.x 版本，使用 apollo-server-koa 模块去运行 GraphQL 服务。Apollo-GraphQL 是 Node.js 社区里，比较知名和成熟的 GraphQL 框架。做了很多的细节工作，也有一些相对前沿的探索，比如 Apollo Federation 架构等。不过，有两点值得一提：1）Apollo-GraphQL 属于 GraphQL 社区的一部分，而非 Facebook 官方的 GraphQL 开发团队。Apollo-GraphQL 在官方 GraphQL 的基础上进行了带有他们自身理念特点的封装和设计。像 Apollo Federation 这类目前看来比较激进的方案，即使是 GraphQL 官方的开发人员，对此也持保留态度。2）Apollo-GraphQL 的重心是前文所说的第一类 API Gateway 角色的 GraphQL 服务，本文探讨的是第二类。因此，Apollo-GraphQL 里有很多功能对我们来说没必要，有一些功能的使用方式，跟我们的场景也不契合。我们主要使用的是 Apollo-GraphQL 的 graphql-tools 和 apollo-server-koa 两个模块，并在此基础上，进行了符合我们场景的设计和改编。 Decouple schema and resovler: –&gt; Loosly couple 松耦合 | 紧耦合 1. Merge 多个 GraphQL-Service 的 Schema 后生成的结果。可以看出来，跟之前手写的版本，总体上是一样的 2. TypeScript + GraphQL = TypeGraphQLhttps://zhuanlan.zhihu.com/p/56516614https://github.com/MichalLytek/type-graphql GraphQL 快速入门教程https://zhuanlan.zhihu.com/p/75618997https://github.com/MudOnTire/graphQL-tutorial How to build an Apollo GraphQL server with TypeScript and Webpack Hot Module Replacementhttps://medium.com/free-code-camp/build-an-apollo-graphql-server-with-typescript-and-webpack-hot-module-replacement-hmr-3c339d05184fhttps://github.com/apollographql/apollo-server/tree/master/packages/apollo-server-express Running an Express GraphQL Serverhttps://graphql.org/graphql-js/running-an-express-graphql-server/https://graphql.org/blog/mocking-with-graphql/https://graphql.org/blog/graphql-a-query-language/https://graphql.org/community/https://launchpad.graphql.com/98lq7vz8r Cannot use graphQL server with express routerhttps://github.com/apollographql/apollo-server/issues/336 GraphQL is the better RESThttps://www.graphql.com/https://www.howtographql.com/basics/1-graphql-is-the-better-rest/ 如何将 Web 主页性能提升十倍以上？https://www.infoq.cn/article/Xxyy8WZrWLwUlIF0*IxR","tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://blog.v2next.com/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://blog.v2next.com/tags/Apollo/"},{"name":"Web API","slug":"Web-API","permalink":"https://blog.v2next.com/tags/Web-API/"},{"name":"NodeJs","slug":"NodeJs","permalink":"https://blog.v2next.com/tags/NodeJs/"},{"name":"Evaluation","slug":"Evaluation","permalink":"https://blog.v2next.com/tags/Evaluation/"},{"name":"Frontend Architecture","slug":"Frontend-Architecture","permalink":"https://blog.v2next.com/tags/Frontend-Architecture/"}]},{"title":"Micro Frontends In Action","date":"2019-08-18T08:18:10.000Z","path":"2019/08/18/Micro-Frontends-In-Action/","text":"新部门的前端项目架构中实践了微前端，后面有时间再整理内容，下面开发中收集的一些资料。 Micro frontendshttps://martinfowler.com/articles/micro-frontends.html https://github.com/micro-frontends-demo https://micro-frontends.org/ Single SPAhttps://github.com/CanopyTax/single-spahttps://single-spa.js.org/https://single-spa.surge.sh/ Building Micro Frontends with React, Vue, and Single-spahttps://github.com/dabit3/micro-frontend-examplehttps://dev.to/dabit3/building-micro-frontends-with-react-vue-and-single-spa-52op qiankun（乾坤）：An implementation of Micro Frontends, based on single-spa, but made it production-ready.📦🚀Blazing fast, simple and completed solution for micro frontends.https://github.com/umijs/qiankun 可能是你见过最完善的微前端解决方案https://zhuanlan.zhihu.com/p/78362028 微前端如何落地？https://zhuanlan.zhihu.com/p/73090920 Micro frontends—a microservice approach to front-end web developmenthttps://medium.com/@tomsoderlund/micro-frontends-a-microservice-approach-to-front-end-web-development-f325ebdadc16 typescript+nodejs 是否适合开发大型项目？https://www.zhihu.com/question/338345340/answer/778069075 Monorepo——大型前端项目的代码管理方式https://segmentfault.com/a/1190000019309820 Google repo mgmt:https://zhuanlan.zhihu.com/p/50564255","tags":[{"name":"React","slug":"React","permalink":"https://blog.v2next.com/tags/React/"},{"name":"Frontend Architecture","slug":"Frontend-Architecture","permalink":"https://blog.v2next.com/tags/Frontend-Architecture/"},{"name":"Micro Frontends","slug":"Micro-Frontends","permalink":"https://blog.v2next.com/tags/Micro-Frontends/"}]},{"title":"使用 Docker Compose 部署 NodeJS Web App","date":"2019-04-10T06:48:38.000Z","path":"2019/04/10/docker-compose-for-node-webapp/","text":"上一篇 Post 使用了 Docker 化 Node.js 的 Web App，这一篇 Post 尝试玩下 docker compose。😊 Dockerfile 和 dockerignore 前面已经创建过 🔗atlas-app 新建 docker-compose.yml 1234567891011app: build: ./ volumes: - ./:/usr/src/app ports: - 8888:6075 environment: - NODE_ENV=development - PORT=6075 command: \"npm start\" restart: always 8888 是宿主机 IP 和端口，6075 是跑在 docker 里 app 的端口 构建和运行 1docker-compose -f ./docker-compose.yml up -d 查看 containers 和对应的 logs 1docker ps 1docker logs &lt;container id&gt; 执行容器中 bash 1docker exec -it &lt;container id&gt; /bin/bash 参考资料： 🔗 A Docker/docker-compose setup with Redis and Node/Express 🔗 Using Docker Compose for NodeJS Development 🔗 使用 docker-composer 部署 nodejs 应用","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://blog.v2next.com/tags/NodeJS/"},{"name":"Docker Compose","slug":"Docker-Compose","permalink":"https://blog.v2next.com/tags/Docker-Compose/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.v2next.com/tags/Docker/"},{"name":"Web App","slug":"Web-App","permalink":"https://blog.v2next.com/tags/Web-App/"}]},{"title":"Docker 化 Node.js 的 Web App","date":"2019-03-15T05:54:17.000Z","path":"2019/03/15/nodejs-docker-webapp/","text":"首先通过git clone命令在本地 clone 好一个 node app。 1git clone https://github.com/ericwdq/atlas-app.git 然后准备为 App 创建一个 Docker 镜像，最后再将创建的镜像运作在一个容器中。 Docker 可以把具有所有依赖关系的 App 打包到一个标准化单元的容器用于软件开发。 容器是 Linux 中基础概念，镜像就是运行在容器中的应用程序。 运行 App 在 Docker 上 创建 Dockerfile 文件在 App 的根目录 12345678910111213141516171819202122FROM node:8# Create app directoryWORKDIR /usr/src/app# Install app dependencies# A wildcard is used to ensure both package.json AND package-lock.json are copied# where available (npm@5+)COPY package*.json ./RUN npm install# If you are building your code for production# RUN npm ci --only=production# Bundle app sourceCOPY . .# Expose app portsEXPOSE 6075# Start applicationCMD [ \"npm\", \"start\" ] 创建 dockerignore 文件在 App 的根目录 12node_modulesnpm-debug.log 构建镜像 1docker build -t eric/atlas-app . 上面的 . 代表当前目录 查看 docker 镜像列表 1docker images REPOSITORY TAG IMAGE ID CREATED SIZE eric/atlas-app latest d6e01bdfc655 40 minutes ago 1.24GB 运行容器 1docker run -p 8888:6075 -d -it eric/atlas-app 上面的示例，Docker 将映射容器中的 6075 端口到 8888 你的机器的端口上，所以你可以访问 8888 端口去测试 app。当然你也可以使用的相同的端口转发。 获取容器的 ID 1docker ps 打印 app 的日志 1docker logs &lt;container id&gt; 测试访问 app urlhttp://localhost:8888 执行容器中的 bash 1docker exec -it &lt;container id&gt; /bin/bash 删除容器 1docker rm --force &lt;container id&gt; 删除镜像 1docker rmi Image &lt;container id&gt; 参考资料： 🔗 Dockerizing a Node.js web app 下一步准备尝试使用 docker compose 多容器控制和自动化。 😊 🔗 Using Docker Compose for NodeJS Development 🔗 使用 docker-composer 部署 nodejs 应用","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://blog.v2next.com/tags/NodeJS/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.v2next.com/tags/Docker/"},{"name":"Web App","slug":"Web-App","permalink":"https://blog.v2next.com/tags/Web-App/"}]},{"title":"React Hooks with Typescript","date":"2019-02-15T09:21:46.000Z","path":"2019/02/15/react-hooks-with-ts/","text":"React Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class. - from reactjs.org React Hooks with TypeScript🔗 https://blog.usejournal.com/using-react-hooks-with-typescript-aae6c7b2a3a9 🔗 https://react-hooks-typescript.now.sh/ 🔗 https://github.com/ericwdq/react-hooks-typescript-example Code sandbox live demo:🔗 https://codesandbox.io/s/github/skovy/react-hooks-typescript-example 🔗 How to Use Typescript with React and Reduxhttps://medium.com/@rossbulat/how-to-use-typescript-with-react-and-redux-a118b1e02b76 UseStateUseEffectUseReducerUseContextTypescript:https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html","tags":[{"name":"React","slug":"React","permalink":"https://blog.v2next.com/tags/React/"},{"name":"React Hooks","slug":"React-Hooks","permalink":"https://blog.v2next.com/tags/React-Hooks/"},{"name":"ts","slug":"ts","permalink":"https://blog.v2next.com/tags/ts/"},{"name":"Typescript","slug":"Typescript","permalink":"https://blog.v2next.com/tags/Typescript/"}]},{"title":"React Hooks 开发 Todo List","date":"2018-12-06T06:45:59.000Z","path":"2018/12/06/react-hooks/","text":"Introducing Hookshttps://reactjs.org/docs/hooks-intro.html How to Build a Todo List with React Hookshttps://medium.freecodecamp.org/how-to-build-a-todo-list-with-react-hooks-ebaa4e3db3b https://codesandbox.io/s/github/yazeedb/react-hooks-todo","tags":[{"name":"React","slug":"React","permalink":"https://blog.v2next.com/tags/React/"},{"name":"React Hooks","slug":"React-Hooks","permalink":"https://blog.v2next.com/tags/React-Hooks/"}]},{"title":"安装 nvm and NodeJS 在 SUSE/Linux 环境","date":"2018-12-03T08:54:46.000Z","path":"2018/12/03/install-nvm-and-nodejs-on-SUSE-Linux/","text":"公司的项目产品 server build 的环境是 SUSE Linux ，所以前端项目构建使用的 NodeJS 是 linux 版本，研究了下 nvm 和 NodeJS 在 SUSE 的安装。 安装步骤 查看系统信息： 1$ lsb_release -a; uname -a; arch 执行结果： cnpvg50842594:~/.nvm/versions/node # lsb_release -a; uname -a; arch LSB Version: n/a Distributor ID: SUSE LINUX Description: SUSE Linux Enterprise Server 12 SP1 Release: 12.1 Codename: n/a Linux cnpvg50842594 3.12.74-60.64.40-xen #1 SMP Wed May 10 05:07:16 UTC 2017 (4eb35ec) x86_64 x86_64 x86_64 GNU/Linux x86_64 下载安装 nvm： 1$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.10/install.sh | bash 编辑配置文件，添加.nvm： 1$ vim ~/.bashrc export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm 1$ source ~/.bashrc nvm github 安装脚本：https://github.com/creationix/nvm#install-script 查看 nvm 命令： 1$ command -v nvm 安装 nodejs 1$ nvm install 10.14.0 [arch] 查看已安装的 nodejs 列表 1nvm list 下面有个 Youtobe 视频，基本安装步骤差不多。https://www.youtube.com/watch?v=MYXRbXabmsc","tags":[{"name":"nvm","slug":"nvm","permalink":"https://blog.v2next.com/tags/nvm/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://blog.v2next.com/tags/NodeJS/"},{"name":"SUSE","slug":"SUSE","permalink":"https://blog.v2next.com/tags/SUSE/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.v2next.com/tags/Linux/"}]},{"title":"使用 JSON Web Token","date":"2018-11-06T02:53:26.000Z","path":"2018/11/06/jwt-auth/","text":"Here are some scenarios where JSON Web Tokens are useful: Authorization: This is the most common scenario for using JWT. Once the user is logged in, each subsequent request will include the JWT, allowing the user to access routes, services, and resources that are permitted with that token. Single Sign On is a feature that widely uses JWT nowadays, because of its small overhead and its ability to be easily used across different domains. Information Exchange: JSON Web Tokens are a good way of securely transmitting information between parties. Because JWTs can be signed—for example, using public/private key pairs—you can be sure the senders are who they say they are. Additionally, as the signature is calculated using the header [GitHub] Understanding JWT (JSON web token) authenticationhttps://github.com/ericwdq/jwt-auth 不要用 JWT 替代 session 管理（上）：全面了解 Token,JWT,OAuth,SAML,SSOhttps://zhuanlan.zhihu.com/p/38942172 jwt.iohttps://jwt.io/introduction/","tags":[{"name":"JSON Web Token","slug":"JSON-Web-Token","permalink":"https://blog.v2next.com/tags/JSON-Web-Token/"},{"name":"JWT","slug":"JWT","permalink":"https://blog.v2next.com/tags/JWT/"},{"name":"auth","slug":"auth","permalink":"https://blog.v2next.com/tags/auth/"}]},{"title":"You Don't Need jQuery","date":"2018-09-12T02:36:13.000Z","path":"2018/09/12/you-dont-need-jquery-cn/","text":"📰 GitHub 工程团队发布文章 🔗Removing jQuery from GitHub.com frontend 宣布他们将逐渐脱离 jQuery，直到能够完全删除库，使用浏览器原生的 APIs 可以满足所有需求。我清晰的记得刚开始 jQuery 的时候，使前端开发工作变的简单，高效。所以不得不说 jQuery 是一个伟大的库，❤️ 纪念一下，感谢 jQuery！ 我在 Github 上发现了这个很实用的 repo！🔗You Don’t Need jQuery 有很多翻译版本，下面是中文版。 前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。 目录 Query Selector CSS &amp; Style DOM Manipulation Ajax Events Utilities Promises Animation Alternatives Browser Support Query Selector常用的 class、id、属性 选择器都可以使用 document.querySelector 或 document.querySelectorAll 替代。区别是 document.querySelector 返回第一个匹配的 Element document.querySelectorAll 返回所有匹配的 Element 组成的 NodeList。它可以通过 [].slice.call() 把它转成 Array 如果匹配不到任何 Element，jQuery 返回空数组 []，但 document.querySelector 返回 null，注意空指针异常。当找不到时，也可以使用 || 设置默认的值，如 document.querySelectorAll(selector) || [] 注意：document.querySelector 和 document.querySelectorAll 性能很差。如果想提高性能，尽量使用 document.getElementById、document.getElementsByClassName 或 document.getElementsByTagName。 1.0 选择器查询 12345// jQuery$(\"selector\");// Nativedocument.querySelectorAll(\"selector\"); 1.1 class 查询 12345678// jQuery$(\".class\");// Nativedocument.querySelectorAll(\".class\");// ordocument.getElementsByClassName(\"class\"); 1.2 id 查询 12345678// jQuery$(\"#id\");// Nativedocument.querySelector(\"#id\");// ordocument.getElementById(\"id\"); 1.3 属性查询 12345// jQuery$(\"a[target=_blank]\");// Nativedocument.querySelectorAll(\"a[target=_blank]\"); 1.4 后代查询 12345// jQuery$el.find(\"li\");// Nativeel.querySelectorAll(\"li\"); 1.5 兄弟及上下元素 兄弟元素 123456789// jQuery$el.siblings();// Native - latest, Edge13+[...el.parentNode.children].filter(child =&gt; child !== el);// Native (alternative) - latest, Edge13+Array.from(el.parentNode.children).filter(child =&gt; child !== el);// Native - IE10+Array.prototype.filter.call(el.parentNode.children, child =&gt; child !== el); 上一个元素 12345// jQuery$el.prev();// Nativeel.previousElementSibling; 下一个元素 12345// next$el.next();// Nativeel.nextElementSibling; 1.6 Closest Closest 获得匹配选择器的第一个祖先元素，从当前元素开始沿 DOM 树向上。 1234567891011121314151617181920212223// jQuery$el.closest(queryString);// Native - Only latest, NO IEel.closest(selector);// Native - IE10+function closest(el, selector) &#123; const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector; while (el) &#123; if (matchesSelector.call(el, selector)) &#123; return el; &#125; else &#123; el = el.parentElement; &#125; &#125; return null;&#125; 1.7 Parents Until 获取当前每一个匹配元素集的祖先，不包括匹配元素的本身。 1234567891011121314151617181920212223242526// jQuery$el.parentsUntil(selector, filter);// Nativefunction parentsUntil(el, selector, filter) &#123; const result = []; const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector; // match start from parent el = el.parentElement; while (el &amp;&amp; !matchesSelector.call(el, selector)) &#123; if (!filter) &#123; result.push(el); &#125; else &#123; if (matchesSelector.call(el, filter)) &#123; result.push(el); &#125; &#125; el = el.parentElement; &#125; return result;&#125; 1.8 Form Input/Textarea 12345// jQuery$(\"#my-input\").val();// Nativedocument.querySelector(\"#my-input\").value; 获取 e.currentTarget 在 .radio 中的数组索引 12345678// jQuery$(\".radio\").index(e.currentTarget);// NativeArray.prototype.indexOf.call( document.querySelectorAll(\".radio\"), e.currentTarget); 1.9 Iframe Contents jQuery 对象的 iframe contents() 返回的是 iframe 内的 document Iframe contents 12345// jQuery$iframe.contents();// Nativeiframe.contentDocument; Iframe Query 12345// jQuery$iframe.contents().find(\".css\");// Nativeiframe.contentDocument.querySelectorAll(\".css\"); 1.10 获取 body 12345// jQuery$(\"body\");// Nativedocument.body; 1.11 获取或设置属性 获取属性 12345// jQuery$el.attr(\"foo\");// Nativeel.getAttribute(\"foo\"); 设置属性 12345// jQuery, note that this works in memory without change the DOM$el.attr(\"foo\", \"bar\");// Nativeel.setAttribute(\"foo\", \"bar\"); 获取 data- 属性 12345678// jQuery$el.data(\"foo\");// Native (use `getAttribute`)el.getAttribute(\"data-foo\");// Native (use `dataset` if only need to support IE 11+)el.dataset[\"foo\"]; ⬆ 回到顶部 CSS &amp; Style 2.1 CSS Get style 123456789// jQuery$el.css(\"color\");// Native// 注意：此处为了解决当 style 值为 auto 时，返回 auto 的问题const win = el.ownerDocument.defaultView;// null 的意思是不返回伪类元素win.getComputedStyle(el, null).color; Set style 12345// jQuery$el.css(&#123; color: \"#ff0011\" &#125;);// Nativeel.style.color = \"#ff0011\"; Get/Set Styles 注意，如果想一次设置多个 style，可以参考 oui-dom-utils 中 setStyles 方法 Add class 12345// jQuery$el.addClass(className);// Nativeel.classList.add(className); Remove class 12345// jQuery$el.removeClass(className);// Nativeel.classList.remove(className); has class 12345// jQuery$el.hasClass(className);// Nativeel.classList.contains(className); Toggle class 12345// jQuery$el.toggleClass(className);// Nativeel.classList.toggle(className); 2.2 Width &amp; Height Width 与 Height 获取方法相同，下面以 Height 为例： Window height 12345678// window height$(window).height();// 含 scrollbarwindow.document.documentElement.clientHeight;// 不含 scrollbar，与 jQuery 行为一致window.innerHeight; Document height 12345678910111213// jQuery$(document).height();// Nativeconst body = document.body;const html = document.documentElement;const height = Math.max( body.offsetHeight, body.scrollHeight, html.clientHeight, html.offsetHeight, html.scrollHeight); Element height 123456789101112131415161718192021// jQuery$el.height();// Nativefunction getHeight(el) &#123; const styles = this.getComputedStyle(el); const height = el.offsetHeight; const borderTopWidth = parseFloat(styles.borderTopWidth); const borderBottomWidth = parseFloat(styles.borderBottomWidth); const paddingTop = parseFloat(styles.paddingTop); const paddingBottom = parseFloat(styles.paddingBottom); return ( height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom );&#125;// 精确到整数（border-box 时为 height - border 值，content-box 时为 height + padding 值）el.clientHeight;// 精确到小数（border-box 时为 height 值，content-box 时为 height + padding + border 值）el.getBoundingClientRect().height; 2.3 Position &amp; Offset Position 获得匹配元素相对父元素的偏移 12345// jQuery$el.position();// Native&#123; left: el.offsetLeft, top: el.offsetTop &#125; Offset 获得匹配元素相对文档的偏移 12345678910111213// jQuery$el.offset();// Nativefunction getOffset(el) &#123; const box = el.getBoundingClientRect(); return &#123; top: box.top + window.pageYOffset - document.documentElement.clientTop, left: box.left + window.pageXOffset - document.documentElement.clientLeft &#125;;&#125; 2.4 Scroll Top 获取元素滚动条垂直位置。 123456// jQuery$(window).scrollTop();// Native(document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop; ⬆ 回到顶部 DOM Manipulation 3.1 Remove 从 DOM 中移除元素。 12345// jQuery$el.remove();// Nativeel.parentNode.removeChild(el); 3.2 Text Get text 返回指定元素及其后代的文本内容。 12345// jQuery$el.text();// Nativeel.textContent; Set text 设置元素的文本内容。 12345// jQuery$el.text(string);// Nativeel.textContent = string; 3.3 HTML Get HTML 12345// jQuery$el.html();// Nativeel.innerHTML; Set HTML 12345// jQuery$el.html(htmlString);// Nativeel.innerHTML = htmlString; 3.4 Append Append 插入到子节点的末尾 12345678// jQuery$el.append(\"&lt;div id='container'&gt;hello&lt;/div&gt;\");// Native (HTML string)el.insertAdjacentHTML(\"beforeend\", '&lt;div id=\"container\"&gt;Hello World&lt;/div&gt;');// Native (Element)el.appendChild(newEl); 3.5 Prepend 12345678// jQuery$el.prepend(\"&lt;div id='container'&gt;hello&lt;/div&gt;\");// Native (HTML string)el.insertAdjacentHTML(\"afterbegin\", '&lt;div id=\"container\"&gt;Hello World&lt;/div&gt;');// Native (Element)el.insertBefore(newEl, el.firstChild); 3.6 insertBefore 在选中元素前插入新节点 1234567891011121314// jQuery$newEl.insertBefore(queryString);// Native (HTML string)el.insertAdjacentHTML( \"beforebegin \", '&lt;div id=\"container\"&gt;Hello World&lt;/div&gt;');// Native (Element)const el = document.querySelector(selector);if (el.parentNode) &#123; el.parentNode.insertBefore(newEl, el);&#125; 3.7 insertAfter 在选中元素后插入新节点 1234567891011// jQuery$newEl.insertAfter(queryString);// Native (HTML string)el.insertAdjacentHTML(\"afterend\", '&lt;div id=\"container\"&gt;Hello World&lt;/div&gt;');// Native (Element)const el = document.querySelector(selector);if (el.parentNode) &#123; el.parentNode.insertBefore(newEl, el.nextSibling);&#125; 3.8 is 如果匹配给定的选择器，返回 true 12345// jQuery$el.is(selector);// Nativeel.matches(selector); 3.9 clone 深拷贝被选元素。（生成被选元素的副本，包含子节点、文本和属性。） 12345//jQuery$el.clone();//Nativeel.cloneNode(); //深拷贝添加参数‘true’ 1234567891011- [3.10](#3.10) &lt;a name=&apos;3.10&apos;&gt;&lt;/a&gt; empty 移除所有子节点```javascript//jQuery$el.empty();//Nativeel.innerHTML = &quot;&quot;; 3.11 wrap 把每个被选元素放置在指定的 HTML 结构中。 1234567891011//jQuery$(\".inner\").wrap('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;');//NativeArray.prototype.forEach.call(document.querySelector(\".inner\"), el =&gt; &#123; const wrapper = document.createElement(\"div\"); wrapper.className = \"wrapper\"; el.parentNode.insertBefore(wrapper, el); el.parentNode.removeChild(el); wrapper.appendChild(el);&#125;); 3.12 unwrap 移除被选元素的父元素的 DOM 结构 123456789101112// jQuery$(\".inner\").unwrap();// NativeArray.prototype.forEach.call(document.querySelectorAll(\".inner\"), el =&gt; &#123; let elParentNode = el.parentNode; if (elParentNode !== document.body) &#123; elParentNode.parentNode.insertBefore(el, elParentNode); elParentNode.parentNode.removeChild(elParentNode); &#125;&#125;); 3.13 replaceWith 用指定的元素替换被选的元素 12345678910//jQuery$(\".inner\").replaceWith('&lt;div class=\"outer\"&gt;&lt;/div&gt;');//NativeArray.prototype.forEach.call(document.querySelectorAll(\".inner\"), el =&gt; &#123; const outer = document.createElement(\"div\"); outer.className = \"outer\"; el.parentNode.insertBefore(outer, el); el.parentNode.removeChild(el);&#125;); 3.14 simple parse 解析 HTML/SVG/XML 字符串 12345678910111213141516171819202122// jQuery$(`&lt;ol&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt;&lt;/ol&gt;&lt;ol&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt;&lt;/ol&gt;`);// Nativerange = document.createRange();parse = range.createContextualFragment.bind(range);parse(`&lt;ol&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt;&lt;/ol&gt;&lt;ol&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt;&lt;/ol&gt;`); ⬆ 回到顶部 AjaxFetch API 是用于替换 XMLHttpRequest 处理 ajax 的新标准，Chrome 和 Firefox 均支持，旧浏览器可以使用 polyfills 提供支持。 IE9+ 请使用 github/fetch，IE8+ 请使用 fetch-ie8，JSONP 请使用 fetch-jsonp。 4.1 从服务器读取数据并替换匹配元素的内容。 12345678910// jQuery$(selector).load(url, completeCallback);// Nativefetch(url) .then(data =&gt; data.text()) .then(data =&gt; &#123; document.querySelector(selector).innerHTML = data; &#125;) .then(completeCallback); ⬆ 回到顶部 Events完整地替代命名空间和事件代理，链接到 https://github.com/oneuijs/oui-dom-events 5.0 Document ready by DOMContentLoaded 12345678910// jQuery$(document).ready(eventHandler);// Native// 检测 DOMContentLoaded 是否已完成if (document.readyState !== \"loading\") &#123; eventHandler();&#125; else &#123; document.addEventListener(\"DOMContentLoaded\", eventHandler);&#125; 5.1 使用 on 绑定事件 12345// jQuery$el.on(eventName, eventHandler);// Nativeel.addEventListener(eventName, eventHandler); 5.2 使用 off 解绑事件 12345// jQuery$el.off(eventName, eventHandler);// Nativeel.removeEventListener(eventName, eventHandler); 5.3 Trigger 123456789101112// jQuery$(el).trigger(\"custom-event\", &#123; key1: \"data\" &#125;);// Nativeif (window.CustomEvent) &#123; const event = new CustomEvent(\"custom-event\", &#123; detail: &#123; key1: \"data\" &#125; &#125;);&#125; else &#123; const event = document.createEvent(\"CustomEvent\"); event.initCustomEvent(\"custom-event\", true, true, &#123; key1: \"data\" &#125;);&#125;el.dispatchEvent(event); ⬆ 回到顶部 Utilities大部分实用工具都能在 native API 中找到. 其他高级功能可以选用专注于该领域的稳定性和性能都更好的库来代替，推荐 lodash。 6.1 基本工具 isArray 检测参数是不是数组。 12345// jQuery$.isArray(range);// NativeArray.isArray(range); isWindow 检测参数是不是 window。 1234567// jQuery$.isWindow(obj);// Nativefunction isWindow(obj) &#123; return obj !== null &amp;&amp; obj !== undefined &amp;&amp; obj === obj.window;&#125; inArray 在数组中搜索指定值并返回索引 (找不到则返回 -1)。 12345678// jQuery$.inArray(item, array);// Nativearray.indexOf(item) &gt; -1;// ES6-wayarray.includes(item); isNumeric 检测传入的参数是不是数字。Use typeof to decide the type or the type example for better accuracy. 1234567// jQuery$.isNumeric(item);// Nativefunction isNumeric(n) &#123; return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#125; isFunction 检测传入的参数是不是 JavaScript 函数对象。 12345678910111213// jQuery$.isFunction(item);// Nativefunction isFunction(item) &#123; if (typeof item === \"function\") &#123; return true; &#125; var type = Object.prototype.toString(item); return ( type === \"[object Function]\" || type === \"[object GeneratorFunction]\" );&#125; isEmptyObject 检测对象是否为空 (包括不可枚举属性). 1234567// jQuery$.isEmptyObject(obj);// Nativefunction isEmptyObject(obj) &#123; return Object.keys(obj).length === 0;&#125; isPlainObject 检测是不是扁平对象 (使用 “{}” 或 “new Object” 创建). 12345678910111213141516171819202122232425// jQuery$.isPlainObject(obj);// Nativefunction isPlainObject(obj) &#123; if ( typeof obj !== \"object\" || obj.nodeType || (obj !== null &amp;&amp; obj !== undefined &amp;&amp; obj === obj.window) ) &#123; return false; &#125; if ( obj.constructor &amp;&amp; !Object.prototype.hasOwnProperty.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) &#123; return false; &#125; return true;&#125; extend 合并多个对象的内容到第一个对象。object.assign 是 ES6 API，也可以使用 polyfill。 12345// jQuery$.extend(&#123;&#125;, defaultOpts, opts);// NativeObject.assign(&#123;&#125;, defaultOpts, opts); trim 移除字符串头尾空白。 12345// jQuery$.trim(string);// Nativestring.trim(); map 将数组或对象转化为包含新内容的数组。 12345// jQuery$.map(array, (value, index) =&gt; &#123;&#125;);// Nativearray.map((value, index) =&gt; &#123;&#125;); each 轮询函数，可用于平滑的轮询对象和数组。 12345// jQuery$.each(array, (index, value) =&gt; &#123;&#125;);// Nativearray.forEach((value, index) =&gt; &#123;&#125;); grep 找到数组中符合过滤函数的元素。 12345// jQuery$.grep(array, (value, index) =&gt; &#123;&#125;);// Nativearray.filter((value, index) =&gt; &#123;&#125;); type 检测对象的 JavaScript [Class] 内部类型。 1234567891011// jQuery$.type(obj);// Nativefunction type(item) &#123; const reTypeOf = /(?:^\\[object\\s(.*?)\\]$)/; return Object.prototype.toString .call(item) .replace(reTypeOf, \"$1\") .toLowerCase();&#125; merge 合并第二个数组内容到第一个数组。 12345678910111213141516// jQuery$.merge(array1, array2);// Native// 使用 concat，不能去除重复值function merge(...args) &#123; return [].concat(...args);&#125;// ES6，同样不能去除重复值array1 = [...array1, ...array2];// 使用 Set，可以去除重复值function merge(...args) &#123; return Array.from(new Set([].concat(...args)));&#125; now 返回当前时间的数字呈现。 12345// jQuery$.now();// NativeDate.now(); proxy 传入函数并返回一个新函数，该函数绑定指定上下文。 12345// jQuery$.proxy(fn, context);// Nativefn.bind(context); makeArray 类数组对象转化为真正的 JavaScript 数组。 12345678// jQuery$.makeArray(arrayLike);// NativeArray.prototype.slice.call(arrayLike);// ES6-wayArray.from(arrayLike); 6.2 包含 检测 DOM 元素是不是其他 DOM 元素的后代. 12345// jQuery$.contains(el, child);// Nativeel !== child &amp;&amp; el.contains(child); 6.3 Globaleval 全局执行 JavaScript 代码。 12345678910111213// jQuery$.globaleval(code);// Nativefunction Globaleval(code) &#123; const script = document.createElement(\"script\"); script.text = code; document.head.appendChild(script).parentNode.removeChild(script);&#125;// Use eval, but context of eval is current, context of $.Globaleval is global.eval(code); 6.4 解析 parseHTML 解析字符串为 DOM 节点数组. 12345678910111213141516// jQuery$.parseHTML(htmlString);// Nativefunction parseHTML(string) &#123; const context = document.implementation.createHTMLDocument(); // Set the base href for the created document so any parsed elements with URLs // are based on the document's URL const base = context.createElement(\"base\"); base.href = document.location.href; context.head.appendChild(base); context.body.innerHTML = string; return context.body.children;&#125; parseJSON 传入格式正确的 JSON 字符串并返回 JavaScript 值. 12345// jQuery$.parseJSON(str);// NativeJSON.parse(str); ⬆ 回到顶部 PromisesPromise 代表异步操作的最终结果。jQuery 用它自己的方式处理 promises，原生 JavaScript 遵循 Promises/A+ 标准实现了最小 API 来处理 promises。 7.1 done, fail, always done 会在 promise 解决时调用，fail 会在 promise 拒绝时调用，always 总会调用。 12345678// jQuery$promise .done(doneCallback) .fail(failCallback) .always(alwaysCallback);// Nativepromise.then(doneCallback, failCallback).then(alwaysCallback, alwaysCallback); 7.2 when when 用于处理多个 promises。当全部 promises 被解决时返回，当任一 promise 被拒绝时拒绝。 123456// jQuery$.when($promise1, $promise2).done((promise1Result, promise2Result) =&gt; &#123;&#125;);// NativePromise.all([$promise1, $promise2]).then([promise1Result, promise2Result] =&gt; &#123;&#125;); 7.3 Deferred Deferred 是创建 promises 的一种方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// jQueryfunction asyncFunc() &#123; const defer = new $.Deferred(); setTimeout(() =&gt; &#123; if (true) &#123; defer.resolve(\"some_value_computed_asynchronously\"); &#125; else &#123; defer.reject(\"failed\"); &#125; &#125;, 1000); return defer.promise();&#125;// Nativefunction asyncFunc() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (true) &#123; resolve(\"some_value_computed_asynchronously\"); &#125; else &#123; reject(\"failed\"); &#125; &#125;, 1000); &#125;);&#125;// Deferred wayfunction defer() &#123; const deferred = &#123;&#125;; const promise = new Promise((resolve, reject) =&gt; &#123; deferred.resolve = resolve; deferred.reject = reject; &#125;); deferred.promise = () =&gt; &#123; return promise; &#125;; return deferred;&#125;function asyncFunc() &#123; const defer = defer(); setTimeout(() =&gt; &#123; if (true) &#123; defer.resolve(\"some_value_computed_asynchronously\"); &#125; else &#123; defer.reject(\"failed\"); &#125; &#125;, 1000); return defer.promise();&#125; ⬆ 回到顶部 Animation 8.1 Show &amp; Hide 12345678// jQuery$el.show();$el.hide();// Native// 更多 show 方法的细节详见 https://github.com/oneuijs/oui-dom-utils/blob/master/src/index.js#L363el.style.display = \"\" | \"inline\" | \"inline-block\" | \"inline-table\" | \"block\";el.style.display = \"none\"; 8.2 Toggle 显示或隐藏元素。 123456789101112// jQuery$el.toggle();// Nativeif ( el.ownerDocument.defaultView.getComputedStyle(el, null).display === \"none\") &#123; el.style.display = \"\" | \"inline\" | \"inline-block\" | \"inline-table\" | \"block\";&#125; else &#123; el.style.display = \"none\";&#125; 8.3 FadeIn &amp; FadeOut 12345678910// jQuery$el.fadeIn(3000);$el.fadeOut(3000);// Nativeel.style.transition = \"opacity 3s\";// fadeInel.style.opacity = \"1\";// fadeOutel.style.opacity = \"0\"; 8.4 FadeTo 调整元素透明度。 12345// jQuery$el.fadeTo(\"slow\", 0.15);// Nativeel.style.transition = \"opacity 3s\"; // 假设 'slow' 等于 3 秒el.style.opacity = \"0.15\"; 8.5 FadeToggle 动画调整透明度用来显示或隐藏。 1234567891011// jQuery$el.fadeToggle();// Nativeel.style.transition = \"opacity 3s\";const &#123; opacity &#125; = el.ownerDocument.defaultView.getComputedStyle(el, null);if (opacity === \"1\") &#123; el.style.opacity = \"0\";&#125; else &#123; el.style.opacity = \"1\";&#125; 8.6 SlideUp &amp; SlideDown 1234567891011// jQuery$el.slideUp();$el.slideDown();// Nativeconst originHeight = \"100px\";el.style.transition = \"height 3s\";// slideUpel.style.height = \"0px\";// slideDownel.style.height = originHeight; 8.7 SlideToggle 滑动切换显示或隐藏。 123456789101112// jQuery$el.slideToggle();// Nativeconst originHeight = \"100px\";el.style.transition = \"height 3s\";const &#123; height &#125; = el.ownerDocument.defaultView.getComputedStyle(el, null);if (parseInt(height, 10) === 0) &#123; el.style.height = originHeight;&#125; else &#123; el.style.height = \"0px\";&#125; 8.8 Animate 执行一系列 CSS 属性动画。 12345678// jQuery$el.animate(&#123; params &#125;, speed);// Nativeel.style.transition = 'all ' + speed;Object.keys(params).forEach((key) =&gt; el.style[key] = params[key];) ⬆ 回到顶部 Alternatives 你可能不需要 jQuery (You Might Not Need jQuery) - 如何使用原生 JavaScript 实现通用事件，元素，ajax 等用法。 npm-dom 以及 webmodules - 在 NPM 上提供独立 DOM 模块的组织 Browser Support Latest ✔ Latest ✔ 10+ ✔ Latest ✔ 6.1+ ✔ LicenseMIT","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.v2next.com/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.v2next.com/tags/JavaScript/"},{"name":"Web","slug":"Web","permalink":"https://blog.v2next.com/tags/Web/"},{"name":"Github","slug":"Github","permalink":"https://blog.v2next.com/tags/Github/"}]},{"title":"关于 WebAssembly / wasm","date":"2018-09-05T06:32:13.000Z","path":"2018/09/05/about-webassembly-wasm/","text":"最近在看 WebAssembly，收集了一些资料。后面准备写一些 samples。 MDN 上关于 WebAssembly 的文档和示例。MDN Github 示例：https://github.com/mdn/webassembly-examplesMDN WebAssembly 文档： https://developer.mozilla.org/en-US/docs/WebAssembly. MS Blazor:微软 Blazor = Browser + Razor 是一个试验的 Web UI 框架基于 C#，Razor 和 HTML， 通过 WebAssembly 运行在浏览器中。 https://blogs.msdn.microsoft.com/webdev/2018/02/06/blazor-experimental-project Blazor demo: https://blazor-demo.github.io/Blazor demo repo: https://github.com/blazor-demo 下面是逛知乎发现的 Vim 和 WIndows 2000 跑在 wasm 上，很赞！👍 非常有趣！😄 WebAssembly Vim:https://github.com/rhysd/vim.wasmhttps://zhuanlan.zhihu.com/p/39879691 WebAssembly Windows 2000:https://yq.aliyun.com/roundtable/289191https://zhuanlan.zhihu.com/p/44076682","tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"https://blog.v2next.com/tags/WebAssembly/"},{"name":"wasm","slug":"wasm","permalink":"https://blog.v2next.com/tags/wasm/"},{"name":"Blazor","slug":"Blazor","permalink":"https://blog.v2next.com/tags/Blazor/"},{"name":"fun","slug":"fun","permalink":"https://blog.v2next.com/tags/fun/"}]},{"title":"用 Vue, React, Angular 构建相同应用程序，区别在哪","date":"2018-08-25T02:21:11.000Z","path":"2018/08/25/react-vs-vue-vs-angular/","text":"🔗用 Vue 和 React 构建相同应用程序，区别在哪？- Infoq 🔗I created the exact same app in React and Vue. Here are the differences. - Medium 🔗I created the same app in React and Vue (Part 2: Angular). - Medium","tags":[{"name":"React","slug":"React","permalink":"https://blog.v2next.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.v2next.com/tags/Vue/"}]},{"title":"使用nodejs开发WebSocket应用","date":"2018-08-20T05:10:10.000Z","path":"2018/08/20/nodejs-websocket/","text":"使用了websocket npm搭建 websocket server, 也可以选择使用 socket.io，但是socket.io 封装比较好，基本不用写什么代码，我还是想写些代码体验一下。 📲 Chat App:https://github.com/ericwdq/ws-chat ✉️ Backend data push:https://github.com/ericwdq/d3-demo","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://blog.v2next.com/tags/NodeJS/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://blog.v2next.com/tags/WebSocket/"},{"name":"ws","slug":"ws","permalink":"https://blog.v2next.com/tags/ws/"},{"name":"npm","slug":"npm","permalink":"https://blog.v2next.com/tags/npm/"}]},{"title":"Javascript Async and Await","date":"2018-03-23T08:58:12.000Z","path":"2018/03/23/Javascript-async-and-await/","text":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_functionhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await","tags":[{"name":"ES2017","slug":"ES2017","permalink":"https://blog.v2next.com/tags/ES2017/"},{"name":"Javascript","slug":"Javascript","permalink":"https://blog.v2next.com/tags/Javascript/"},{"name":"Async","slug":"Async","permalink":"https://blog.v2next.com/tags/Async/"},{"name":"Await","slug":"Await","permalink":"https://blog.v2next.com/tags/Await/"}]},{"title":"Promise使用技巧九则","date":"2018-03-22T07:24:27.000Z","path":"2018/03/22/promising-promise-tips/","text":"本文译自 9 Promising Promise Tips。 工程师们，你们总说 Pormise 好用！但有时候用起来是不是还很懵逼。本文传授给你九条实用的 Promise 使用技巧，帮助你和它建立起良好的关系！ 1. 你可以在 .then 回调里返回 Promise是的！你可以 .then 回调里返回 Promise！ 而且，返回的 promise 会在接下来的 .then 被自动打开（unwrapped）： 12345678.then(r =&gt; &#123; // 这是一个 &#123; statusCode: 200 &#125; promise return serverStatusPromise(r);&#125;).then(resp =&gt; &#123; // 200；注意上面的 promise 被自动 unwrap 了 console.log(resp.statusCode);&#125;) 2. 每次调用 .then 都会产生一个新的 Promise如果你熟悉 JavaScript 的链式调用，对这种用法一定不陌生。 调用 .then 和 .catch 时都会创建一个新的 Promise。这个新的 Promise 可以继续使用 .then 或者 .catch。 1234567var statusProm = fetchServerStatus();var promA = statusProm.then(r =&gt; (r.statusCode === 200 ? \"good\" : \"bad\"));var promB = promA.then(r =&gt; (r === \"good\" ? \"ALL OK\" : \"NOTOK\"));var promC = statusProm.then(r =&gt; fetchThisAnotherThing()); 重点注意， promA、 promB 和 promC 虽然相关，但都是不同的 promise 实例。 我喜欢把这种 .then 链当做一个巨大的水暖系统，如果父节点出了故障，热水将无法流入到自节点中。例如，如果 promB 故障了，其他节点不受影响，但是如果 statusProm 出问题了，其他节点就会被影响，也就是被 rejected。 3. 在任何情况下，Promise resolve/reject 状态都是一致的这是 Promise 之所以好用的原因。简单理解，就是如果一个 promise 在多个地方使用，当它被 resolve 或者 reject 的时候，都会获得通知。 而且 promise 是无法被修改的，因此它可以随意传递。 12345678910111213function yourFunc() &#123; const yourAwesomeProm = makeMeProm(); // 无论坏叔叔如何消费你的 promise，你的 promise 都可以正常工作 yourEvilUncle(yourAwesomeProm); return yourAwesomeProm.then(r =&gt; importantProcessing(r));&#125;function yourEvilUncle(prom) &#123; // 坏叔叔 return prom.then(r =&gt; Promise.reject(\"destroy!!\"));&#125; Promise 的设计避免了恶意的破坏，如我所说：“没事，可以把 promise 随便扔！” 4. Promise 构造函数不是万金油我发现有些工程师在任何地方都会使用 Promise 的 constructor，还认为这就是 promise 的使用方式。这是不对的，根本原因就是 constructor API 与原来 callback API 很像，老的习惯很难改。 如果你的代码中遍布 Promise constructor，你的做法就是错的！ Promise 构造函数正确的使用场景如下： 123456return new Promise((res, rej) =&gt; &#123; fs.readFile(\"/etc/passwd\", function(err, data) &#123; if (err) return rej(err); return res(data); &#125;);&#125;); Promise constructor 只在将回调转成 promise 时使用。 看一个冗余的例子： 1234567891011121314// 错误用法return new Promise((res, rej) =&gt; &#123; var fetchPromise = fetchSomeData(.....); fetchPromise .then(data =&gt; &#123; res(data); // 错误的方式 &#125;) .catch(err =&gt; rej(err))&#125;)// 正确用法// 看上去对就是对的return fetchSomeData(...); 在 Node.js 中，推荐使用 util.promisify。用来将回调 API 转成 promise 式的： 12345678const &#123; promisify &#125; = require(\"util\");const fs = require(\"fs\");const readFileAsync = promisify(fs.readFile);readFileAsync(\"myfile.txt\", \"utf-8\") .then(r =&gt; console.log(r)) .catch(e =&gt; console.error(e)); 5. 使用 Promise.resolveJavaScript 提供了 Promise.resolve API，是产生 Promise 对象的一种快捷方式，这个 promise 对象是被 resolve 的。 123var similarProm = new Promise(res =&gt; res(5));// 相当于var prom = Promise.resolve(5); 这有很多使用场景，我最喜欢的一个是，将一个同步的对象转成一个 promise： 1234// 将一个同步函数转成异步的function foo() &#123; return Promise.resolve(5);&#125; 也可以用来在不确定返回值是普通对象还是 promise 时，将返回值封装为 promise 对象： 12345678910111213function goodProm(maybePromise) &#123; return Promise.resolve(maybePromise);&#125;goodProm(5).then(console.log); // 5// 这个 promise resolve 成 5var sixPromise = fetchMeNumber(6);goodProm(sixPromise).then(console.log); // 6// 5，注意，每层 promise 都被自动 unwrap 了goodProm(Promise.resolve(Promise.resolve(5))).then(console.log); 6. 使用 Promise.reject与 Promise.resolve 类似，它也是一种快捷写法 123var rejProm = new Promise((res, reject) =&gt; reject(5));rejProm.catch(e =&gt; console.log(e)); // 5 我最喜欢的 Promise.reject 的用法是，尽早地 reject： 12345678function foo(myVal) &#123; if (!mVal) &#123; return Promise.reject(new Error(\"myVal is required\")); &#125; return new Promise((res, rej) =&gt; &#123; // 这些将巨大的 callback 转成 promise &#125;);&#125; 在 .then 中使用 reject： 123456.then(val =&gt; &#123; if (val != 5) &#123; return Promise.reject('Not Good'); &#125;&#125;).catch(e =&gt; console.log(e)) // Not Good 7. 使用 Promise.allJavaScript 还提供了 Promise.all，但它不是什么快捷方式。 可以如下总结它的算法： 接受一个 promise 的数组 等待所有这些 promise 完成 返回一个新的 Promise，将所有的 resolve 结果放进一个数组里 只要有一个 promise 失败/rejected，这个新的 promise 将会被 rejected 下例展示了所有 promise 都 resolve 的情况： 12345678var prom1 = Promise.resolve(5);var prom2 = fetchServerStatus(); // returns a promise of &#123;statusCode: 200&#125;Proimise.all([prom1, prom2]).then([val1, val2] =&gt; &#123; // notice that it resolves into an Array console.log(val1); // 5 console.log(val2.statusCode); // 200&#125;) 下例展示有一个失败的情况： 12345678var prom1 = Promise.resolve(5);var prom2 = fetchServerStatus(); // returns a promise of &#123;statusCode: 200&#125;Proimise.all([prom1, prom2]).then([val1, val2] =&gt; &#123; // notice that it resolves into an Array console.log(val1); // 5 console.log(val2.statusCode); // 200&#125;) 注意：Promise.all 是一点不笨，只要有一个 promise 被 reject 了，它就直接 reject，不会等到其他 promise 完成。 8. 不要害怕 reject 或者不要在每一个 .then 后面使用 .catch我们是不是常常感到有很多隐藏的错误没有被处理？ 不用担心像下面这样写： 1return fetchSomeData(...); 你可以在任何你想处理的地方解决或者延续 rejection。 处理掉 rejection这很简单，在 .catch 回调中，无论你返回什么都会变成 resolve，除非你返回一个 Promise.reject，才会延续 rejection。 12345678910.then(() =&gt; 5.length) // &lt;-- something wrong happenned here.catch(e =&gt; &#123; return 5; // &lt;-- making javascript great again&#125;).then(r =&gt; &#123; console.log(r); // 5&#125;).catch(e =&gt; &#123; console.error(e); // this function will never be called :)&#125;) reject rejectionreject rejection 的方法就是什么都不做。通常，父函数比起当前函数更擅长处理 rejection。 要记住一个要点，一旦你写了 .catch 就意味着 rejection 已经被处理了，这与同步的 try/catch 类似。 如果你确实想要阻断 rejection（我强烈不推荐这么做）： 1234567891011.then(() =&gt; 5.length) // &lt;-- something wrong happenned here.catch(e =&gt; &#123; errorLogger(e); // do something impure return Promise.reject(e); // reject it, Yes you can do that!&#125;).then(r =&gt; &#123; console.log(r); // this .then (or any subsequent .then) will never be called as we rejected it above :)&#125;).catch(e =&gt; &#123; console.error(e); //&lt;-- it becomes this catch's problem&#125;) .then(x,y) 和 then(x).catch(x) .then 接受第二个回调参数来处理错误。虽然与 then(x).catch(x) 看一起类似，但却有所不同，不同点在于可捕获的错误。 下面例子很好地说了这个问题： 123456789101112.then(function() &#123; return Promise.reject(new Error('something wrong happened'));&#125;).catch(function(e) &#123; console.error(e); // something wrong happened&#125;);.then(function() &#123; return Promise.reject(new Error('something wrong happened'));&#125;, function(e) &#123; // callback handles error coming from the chain above the current `.then` console.error(e); // no error logged&#125;); 9. 避免 .then 嵌套这个原则理解起来很简单，就是避免在 .then 里面继续使用 .then 或者 .catch。相信我，这绝对是可以避免的。 12345678910111213141516171819// 错误用法request(opts).catch(err =&gt; &#123; if (err.statusCode === 400) &#123; return request(opts) .then(r =&gt; r.text()) .catch(err2 =&gt; console.error(err2)); &#125;&#125;);// 正确用法request(opts) .catch(err =&gt; &#123; if (err.statusCode === 400) &#123; return request(opts); &#125; return Promise.reject(err); &#125;) .then(r =&gt; r.text()) .catch(err =&gt; console.erro(err)); 就算是如下这种情况，也可以使用 Promise.all 来解决： 12345678.then(myVal =&gt; &#123; const promA = foo(myVal); const promB = anotherPromMake(myVal); return promA .then(valA =&gt; &#123; return promB.then(valB =&gt; hungryFunc(valA, valB)); // very hungry! &#125;)&#125;) 可以像下面这样： 123456789.then(myVal =&gt; &#123; const promA = foo(myVal); const promB = anotherPromMake(myVal); return Promise.all([prom, anotherProm])&#125;).then(([valA, valB]) =&gt; &#123; // putting ES6 destructing to good use console.log(valA, valB) // all the resolved values return hungryFunc(valA, valB)&#125;) 好了，真心希望本文可以帮到你更好地理解 Promise！ 原文","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://blog.v2next.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://blog.v2next.com/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://blog.v2next.com/tags/Promise/"}]},{"title":"Parcel，零配置开发 React 应用！","date":"2017-12-28T03:27:17.000Z","path":"2017/12/28/Create-a-React-app-with-zero-configuration-using-Parcel/","text":"本文译自 Create a React app with zero configuration using Parcel 已经经历三四年的发展，社区和技术趋于成熟，它已经成为了前端开发中的必备工具。那问题来了，会有新的工具来挑战 webpack 的地位吗？各位不妨看看本文的 Parcel，说不定就是未来的主角。 一开始使用 React 的痛苦想必大家都经历过。在真正进入编码之前，需要花大量的时间搞清楚如何配置 webpack。 Create React App 项目的流行就是因为它简化了配置，加快了项目初始化的速度。俗话说，成也风云，败也风云。将 webpack 配置隐藏既是它的优点，也是它的缺点。随着项目不断地扩大，你可能想做一些高级配置，就需要将 webpack 配置从 Create React App “拖”（eject）出来，这段配置异常复杂，这就回到了老问题——webpack 还是得学习啊！ 最近，一个新的构建工具 Parcel 出现了，它是零配置的！真的不敢相信有这么好的东西，看起来所有问题都将迎刃而解。 我在一个大项目中尝试使用 Parcel，效果拔群。build 出包经过优化，要知道用 webpack 的时候，我需要花数天时间来实现相同的优化。 我想这个工具潜力无限，我们一起来看看如何使用它来轻松搭建一个 React 应用。 使用 Parcel 开发 React 应用首先，创建一个 NPM 项目： 123mkdir react-parcelcd react-parcelnpm init npm init 会询问你一些问题，直接按 enter 键使用默认值即可。 下一步安装 React、babel 和 Parcel 依赖： 123mkdir react-parcelcd react-parcelnpm init 接下来，创建 .babelrc 文件，告诉 parcel 我们使用 ES6 和 React JSX： 123&#123; \"presets\": [\"env\", \"react\"]&#125; 创建 React App，就两个文件： index.js： 1234567891011import React from \"react\";import ReactDOM from \"react-dom\";class HelloMessage extends React.Component &#123; render() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;var mountNode = document.getElementById(\"app\");ReactDOM.render(&lt;HelloMessage name=\"Jane\" /&gt;, mountNode); index.html: 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;React starter app&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"index.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 现在，只需要在 package.json 添加一个启动脚本就可以把我们的应用跑起来了： 123\"scripts\": &#123; \"start\": \"parcel index.html\",&#125;, 搞定，启动： 1npm start parcel-react - Github Repo 原文","tags":[{"name":"React","slug":"React","permalink":"https://blog.v2next.com/tags/React/"},{"name":"Parcel","slug":"Parcel","permalink":"https://blog.v2next.com/tags/Parcel/"},{"name":"Build System","slug":"Build-System","permalink":"https://blog.v2next.com/tags/Build-System/"}]},{"title":"聊一聊性能优化","date":"2017-12-27T03:28:08.000Z","path":"2017/12/27/Talk-about-performance-optimization/","text":"不管是应付前端面试还是改进产品体验，性能优化都是躲不开的话题。这里我们就简单聊一聊性能优化。 传输快 vs 体验快优化的目的是让用户有“快”的感受，那如何让用户感受到快呢？ 加载速度真的很快，用户打开输入网址按下回车立即看到了页面加载速度并没有变快，但用户感觉你的网站很快 传输快所谓的真快就是网站资源以最快的速度到达用户浏览器，那如何去做呢？我们先粗略定一些原则： 传输的内容体积要小 传输的内容数量要少 网速要足够快 服务器响应要及时 能重复利用的资源要利用好 暂时不需要的资源先不要 将来需要的资源抽空要 下面就能顺藤摸瓜，做个细化 传输的内容体积要小 图片要压缩 图片根据支持情况选择体积更小的格式(如 webp) css、js 内容压缩 服务端开启 Gzip，在传输数据之前再次压缩 传输的内容数量要少 图片图标合并（css sprite）、svg 图标合并（svg sprite） css、js 文件打包合并 网速要足够快 服务器出口带宽要够 考虑到南北差异、运营商差异，在不同地区部署服务器 静态资源放 CDN 服务器响应要及时 接口响应速度要快(数据库优化、查询优化、算法优化) cpu、内存、硬盘读写不要成为瓶颈；多加几台机器 重要页面(首页)静态化。服务端提前渲染后首页生成静态页面，用户访问首页直接返回静态页面，不需要像其他页面那样还需加载 css、js 再获取数据渲染展示 能重复利用的资源要利用好 服务器设置合适的静态资源缓存时间 前端文件打包时做合理的分块，让公共的资源缓存后能被多个页面复用 暂时不需要的资源先不要 图片懒加载 功能、模块、组件按需加载 将来需要的资源抽空先拿到 1.DNS 预解析 1&lt;link rel=\"dns-prefetch\" href=\"//jirengu.com\" /&gt; 2.预连接 1&lt;link rel=\"preconnect\" href=\"//jirengu.com\" /&gt; 3.预获取 1&lt;link rel=\"prefetch\" href=\"image.png\" /&gt; 4.预渲染 1&lt;link rel=\"prerender\" href=\"//xiedaimala.com\" /&gt; 体验快所谓的体验快就是让用户觉得网站的交互是“流畅的”、“舒适的”。比如 滚动页面不要有迟滞感 对于短时连续大量触发的操作要做节流 一些常见操作不要感觉拖泥带水 DOM 的操作不要过于频繁 不要出现内存泄露 优化复杂运算 动画不要卡顿 多用 CSS 动画，少用 JS 动画 开启硬件加速 不要用 setTimeout/setInterval 去模拟动画 动画或者过渡的执行时间不要太久 性能优化的建议臆想的优化不是优化，无明显成效的优化不是优化。浏览器的性能已经足够快，不要因为“过渡优化”牺牲代码的可读性 先做简单见效快的优化，再做复杂见效慢的优化。一张未压缩的大图片可能抵消辛辛苦苦做的全部其他技术优化 原文","tags":[{"name":"Frontend","slug":"Frontend","permalink":"https://blog.v2next.com/tags/Frontend/"},{"name":"Performance","slug":"Performance","permalink":"https://blog.v2next.com/tags/Performance/"}]},{"title":"webpack的使用","date":"2017-08-10T08:45:34.000Z","path":"2017/08/10/Use-webpack/","text":"这是一篇对 webpack 的使用介绍，里面的内容多是依据官网例子写出的，如有问题，欢迎指出。参考：https://segmentfault.com/a/1190000008159877http://webpack.github.io/docs/ 原文","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://blog.v2next.com/tags/Javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://blog.v2next.com/tags/webpack/"},{"name":"Module","slug":"Module","permalink":"https://blog.v2next.com/tags/Module/"}]},{"title":"探究Babel生态","date":"2017-08-08T08:40:04.000Z","path":"2017/08/08/Understand-Babel-ecosystem/","text":"本文从 babel 的基础知识，使用方法，如何配置，解析原理和如何开发 babel 插件五个方面让你了解 bablel，以便用 babel 提升开发效率。使用方法和如何配置章节将告诉你在项目中如何使用 babel，解析原理和如何开发 babel 插件章节帮助你开发自己的 babel 插件。 基本介绍相信用 es6/7 写代码的同学对 babel 应该不会陌生，Babel 是用于编写下一代 JavaScript 的编译器。JavaScript 作为一门语言，不断发展更新，新的特性层出不穷，想要提前使用这些特性，必须借助像 babel 这样的编译器。目前主流浏览器最新版本都基本实现了对 es5/6 语法的完全支持，具体请参考兼容性表格,见 http://kangax.github.io/compat-table/es6/ 当你需要使用 es7+语法特性或者兼容旧版本浏览器的需求时，你就需要一款编译器支持将 ES6/7 编译成浏览器支持的 ES5/ES3 代码。Babel 是使用最多的一个。除了编译器，babel 还支持语法扩展（如 react 的 JSX 语法，React 现在已经依赖 babel 编译它的 JSX 语法且弃用了它原有的自定义工具）和静态语法分析（语法检查，代码高亮，压缩，统一代码风格等）。 使用方法本文提到的所有配置的都是 babel6，babel6 废弃了 babel 包，取而代之的是各种模块包，babel6 把所有转换器都分离出去以插件的形式存在，需要单独安装插件包。意味着默认情况下 babel 不会对源码做任何转换，需要自己配置 集成到工具中Webpack 安装： npm install –save-dev babel-loader babel-core 1.webpack配置： module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\" } ] } 2.配置.babelrc文件 安装插件： npm install babel-preset-es2015 babel-plugin-transform-runtime .babelrc { \"presets\": [“es2015”], \"plugins\": [“transform-runtime”] } fis3: ① 安装： npm install –save-dev babel-core fis-parser-babel-6.x ② 配置fis-conf文件： fis.match('src/**.js', { isMod: true, preprocessor: fis.plugin('js-require-css'), parser: fis.plugin('babel-6.x', { sourceMaps: true, }), rExt: '.js' }); ③ 创建.babelrc文件同上 其他工具请参见安装组合方式。http://babeljs.io/docs/setup/#installation 命令行下使用 babel 命令编译babel-register，babel-node原文","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://blog.v2next.com/tags/Javascript/"},{"name":"Babel","slug":"Babel","permalink":"https://blog.v2next.com/tags/Babel/"}]},{"title":"How to handle conflicts with git","date":"2017-07-25T08:25:46.000Z","path":"2017/07/25/How-to-handle-conflicts-with-git/","text":"Forked from https://github.com/Kunena/Kunena-Forum/wiki/How-to-handle-conflicts-with-git How to handle conflicts when merging something with git : When you have a fork and you want update it because you have conflicts, it’s good to know how to do it. Don’t forget to add the remote upstream before doing the following steps. You have done a : $ git fetch upstream and then a : $ git merge upstream/master But it has failed : error: Your local changes to the following files would be overwritten by merge: build/build.number Please, commit your changes or stash them before you can merge. Aborting You have changed something in the file build/build.number, so you have two choices revert you change or if you want lose your change stash it. In my case i do a simple revert : $ git reset --hard HEAD Now it’s good : HEAD is now at 030223c # [#21] Little issue with parent on agora category import You can do the merge : $ git merge upstream/master But now you have a conflict : Auto-merging administrator/components/com_kunenaimporter/CHANGELOG.php CONFLICT (content): Merge conflict in administrator/components/com_kunenaimporte r/CHANGELOG.php Automatic merge failed; fix conflicts and then commit the result. Check the differences : $ git diff diff --cc administrator/components/com_kunenaimporter/CHANGELOG.php index e98aba5,9d74f73..0000000 --- a/administrator/components/com_kunenaimporter/CHANGELOG.php +++ b/administrator/components/com_kunenaimporter/CHANGELOG.php @@@ -31,18 -31,34 +31,49 @@@ Legend KunenaImporter 1.6.5-DEV ++< HEAD +19-July-2011 Xillibit +# [#21] Little issue with parent on agora category import + +18-July-2011 Xillibit +# [#21] Improve ccboard and agora support (improve cat","tags":[{"name":"git","slug":"git","permalink":"https://blog.v2next.com/tags/git/"}]},{"title":"Create a new branch with git and manage branches","date":"2017-07-25T08:25:46.000Z","path":"2017/07/25/Create-a-new-branch-with-git-and-manage-branches/","text":"Forked from https://github.com/Kunena/Kunena-Forum/wiki/Create-a-new-branch-with-git-and-manage-branches In your github fork, you need to keep your master branch clean, by clean I mean without any changes, like that you can create at any time a branch from your master. Each time that you want to commit a bug or a feature, you need to create a branch for it, which will be a copy of your master branch. When you do a pull request on a branch, you can continue to work on another branch and make another pull request on this other branch. Before creating a new branch, pull the changes from upstream. Your master needs to be up to date. Create the branch on your local machine and switch in this branch : $ git checkout -b [name_of_your_new_branch] Change working branch : $ git checkout [name_of_your_new_branch] Push the branch on github : $ git push origin [name_of_your_new_branch] When you want to commit something in your branch, be sure to be in your branch. You can see all branches created by using : $ git branch Which will show : * approval_messages master master_clean Add a new remote for your branch : $ git remote add [name_of_your_remote] Push changes from your commit into your branch : $ git push [name_of_your_new_remote] [name_of_your_branch] Update your branch when the original branch from official repository has been updated : 1$ git fetch [name_of_your_remote] Then you need to apply to merge changes, if your branch is derivated from develop you need to do : $ git merge [name_of_your_remote]/develop Delete a branch on your local filesystem : $ git branch -d [name_of_your_new_branch] To force the deletion of local branch on your filesystem : $ git branch -D [name_of_your_new_branch] Delete the branch on github : $ git push origin :[name_of_your_new_branch] The only difference is the : to say delete, you can do it too by using github interface to remove branch : https://help.github.com/articles/deleting-unused-branches. If you want to change default branch, it’s so easy with github, in your fork go into Admin and in the drop-down list default branch choose what you want. This will push all your branches to the remote, and –set-upstream tracking correctly for you: 1git push --all -u (Not exactly what the OP was asking for, but this one-liner is pretty popular)","tags":[{"name":"git","slug":"git","permalink":"https://blog.v2next.com/tags/git/"}]}]